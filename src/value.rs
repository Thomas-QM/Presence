use model::*;
use sciter::{Value, FromValue};
use std::collections::BTreeMap;
use float_duration::FloatDuration;

//THE FOLLOWING IS DEFINITELY AUTOGENERATED CODE IDK WHO WOULD WRITE THIS SHIT... :) DONT LOOK JUST DONT

//i shouldve used serde....

pub fn dur_val(d: FloatDuration) -> Value {
    Value::duration(d.as_seconds() as f64)
}

pub fn val_dur(v: &Value) -> Option<FloatDuration> {
    v.to_duration().map(FloatDuration::seconds)
}

pub fn opt_val<T: Into<Value>>(x: Option<T>) -> Value {
    x.map(|x| x.into()).unwrap_or_else(|| Value::null())
}

pub fn val_opt<T: FromValue>(v: &Value) -> Option<T> {
    T::from_value(v)
}

pub fn vec_val<T: Into<Value>>(x: Vec<T>) -> Value {
    x.into_iter().map(|x| x.into()).collect()
}

pub fn val_vec<T: FromValue>(x: &Value) -> Option<Vec<T>> {
    let y: Vec<T> = x.values().flat_map(|x| T::from_value(&x).to_vec()).collect();
    if &y.len() == &x.len() {
        Some(y)
    } else { None }
}

pub fn btree_val<T: Into<Value>>(x: BTreeMap<usize, T>) -> Value {
    let mut m = Value::map();
    x.into_iter().for_each(|(k, v)| {
        m.set_item(k as i32, v);
    });

    m
}

impl Into<Value> for ShowTime {
    fn into(self) -> Value {
        match self {
            ShowTime::Elapsed => "elapsed",
            ShowTime::Remaining => "remaining",
            ShowTime::None => "none"
        }.into()
    }
}

impl FromValue for ShowTime {
    fn from_value(v: &Value) -> Option<Self> {
        match v.as_string()?.as_str() {
            "elapsed" => Some(ShowTime::Elapsed),
            "remaining" => Some(ShowTime::Remaining),
            "none" => Some(ShowTime::None),
            _ => None
        }
    }
}

impl Into<Value> for TimePresence {
    fn into(self) -> Value {
        vmap! {
            "details" => self.details,
            "state" => self.state,
            "length" => opt_val(self.length.map(dur_val)),
            "small_image" => self.small_image,
            "large_image" => self.large_image,
            "tooltip" => self.tooltip,
            "show_time" => self.show_time
        }
    }
}

impl FromValue for TimePresence {
    fn from_value(v: &Value) -> Option<Self> {
        Some(TimePresence {
            details: v.get_item("details").as_string()?,
            state: v.get_item("state").as_string()?,
            length: val_dur(&v.get_item("length")),
            small_image: v.get_item("small_image").as_string()?,
            large_image: v.get_item("large_image").as_string()?,
            tooltip: v.get_item("tooltip").as_string()?,
            show_time: ShowTime::from_value(&v.get_item("show_time"))?
        })
    }
}

impl Into<Value> for Presence {
    fn into(self) -> Value {
        vmap!{
            "application_id" => self.application_id.to_string(),
            "name" => self.name,
            "elapsed" => dur_val(self.elapsed),
            "active_presence" => self.active_presence as i32,
            "time_presences" => vec_val(self.time_presences)
        }
    }
}

impl FromValue for Presence {
    fn from_value(v: &Value) -> Option<Self> {
        Some(Presence {
            application_id: v.get_item("application_id").as_string()?.parse().ok()?,
            name: v.get_item("name").as_string()?,
            elapsed: val_dur(&v.get_item("elapsed"))?,
            active_presence: v.get_item("active_presence").to_int()? as usize,
            time_presences: val_vec(&v.get_item("time_presences"))?
        })
    }
}

impl Into<Value> for State {
    fn into(self) -> Value {
        vmap!{
            "current" => self.current as i32,
            "presences" => vec_val(self.presences),
            "update" => self.update
        }
    }
}

impl FromValue for State {
    fn from_value(v: &Value) -> Option<Self> {
        Some(State {
            current: v.get_item("current").to_int()? as usize,
            presences: val_vec(&v.get_item("presences"))?,
            update: v.get_item("update").to_bool()?
        })
    }
}